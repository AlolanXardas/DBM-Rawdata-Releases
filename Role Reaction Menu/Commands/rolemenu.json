{
  "name": "rolemenu",
  "permissions": "NONE",
  "restriction": "1",
  "_id": "DtBMG",
  "actions": [
    {
      "behavior": "1",
      "interpretation": "1",
      "code": "const Discord = require(\"discord.js\")\nlet reactionArray = [];\nlet rectarray = globalVars('reactionRoleInf');\nconst _this = this;\nlet emojiArray = [];\nlet roleArray = [];\nlet errorCatch = 5;\nlet localEmoji;\nlet localEmojiG;\nlet emojiTimerRe = 0;\nvar interval;\nconst fs = require('fs');\nvar embedSettings = [];\n\nlet embedTemplate = new Discord.RichEmbed({\n    color: 0x00FF00,\n    author: {\n        name: client.user.username,\n        icon_url: client.user.avatarURL\n    },\n    title: \"Role Reaction Prompt\",\n    description: \"This is a test embed to showcase what they look like and what they can do.\",\n    timestamp: new Date(),\n})\n\n// Settings\nlet grabAllEmoji = false; // Default: false || Set true if you want the bot to use global emojis from all the servers its in. (May cause slowdowns in larger servers)\nlet roleLimit = 10; // Default: 10 || Sets the maximum number of roles attached to emojis.\nlet debug = false; // Default: false || Prints any errors that may have occured; will also print for await messages that ran out of time\n//\n\nif (grabAllEmoji) {\n    localEmoji = (client || this.getDBM().Bot.bot).emojis.array();\n    localEmojiG = \"Please make sure the emoji you selected is in one of the servers that the bot is in!\";\n} else {\n    localEmoji = msg.guild.emojis.array();\n    localEmojiG = \"Please make sure the emoji you selected is in this server!\";\n}\n\nif (msg.member.hasPermission('MANAGE_ROLES')) {\n    embedTemplate[\"description\"] = `Welcome to the autorole promt.\\n\\nPlease now respond with a title for your reaction embed!`\n    msg.channel.send(embedTemplate)\n        .then((message) => {\n            msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                    max: 1,\n                    time: 60000,\n                    errors: ['time'],\n                })\n                .then(async function(collected) {\n                    embedSettings[0] = collected.first().content;\n                    msg.author.lastMessage.delete();\n                    embedTemplate[\"description\"] = `Your embed title would be **${collected.first().content}**\\n\\nIf you are sure with this title, please now respond with a description for yoru embed.\\nIf not, please respond with \"cancel\"`;\n                    message.edit(embedTemplate);\n                    msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                            max: 1,\n                            time: 60000,\n                            errors: ['time'],\n                        })\n                        .then(async function(collected) {\n                            embedSettings[1] = collected.first().content;\n                            msg.author.lastMessage.delete();\n                            if (collected.first().content.toLowerCase() != \"cancel\") {\n                                embedTemplate[\"description\"] = `Your embed title would be **${embedSettings[0]}** and your description would be:\\n\\n${embedSettings[1]}\\n\\nIf you are satisfyed with this, please respond with \"confirm\".\\nIf not, please respond with \"cancel\".`;\n                                message.edit(embedTemplate);\n\n                                msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                                    max: 1,\n                                    time: 60000,\n                                    errors: ['time'],\n                                })\n                                .then(async function(collected) {\n                                    msg.author.lastMessage.delete();\n                                    if (collected.first().content.toLowerCase() == \"confirm\") {\n                                        reAsk(message, \" \");\n                                    } else {\n                                        message.delete();\n                                        errorMessage('Prompt cancelled, please re-execute the command to go through the prompt again!');\n                                    }\n                                }) .catch((error) => {\n                                    if (debug){\n                                        console.log(error);\n                                    }\n                                    message.delete();\n                                    errorMessage('Sorry, you didnt provide a valid response in time!\\nPlease re-execute the command to go through the prompt again!');\n                                });\n                            } else {\n                                message.delete();\n                                errorMessage(\"Prompt has been cancelled.\\nPlease re-execute the command to go through the prompt again!\");\n                            }\n                            \n                        })\n\n                }).catch((error) => {\n                    if (debug){\n                        console.log(error);\n                    }\n                    message.delete();\n                    errorMessage('Sorry, you didnt provide a valid response in time!\\nPlease re-execute the command to go through the prompt again!');\n                });\n        }) .catch((error) => {\n            if (debug){\n                console.log(error);\n            }\n            message.delete();\n            errorMessage('Sorry, you didnt provide a valid response in time!\\nPlease re-execute the command to go through the prompt again!');\n        });\n\n    function reAsk(message, extra) {\n        if (extra == null) {\n            extra = \"\";\n        }\n        if (reactionArray.length != roleLimit) {\n            var finalText = \"\";\n            reactionArray.forEach(subarray => {\n                finalText = finalText + `${subarray[0]} => ${subarray[2]}\\n`\n            })\n            embedTemplate[\"description\"] = `Please now enter the emoji-role reaction connections (Max ${roleLimit})\\n ${finalText}\\n\\nIf you would like to attach another reaction to a role, please insert a role along with an emoji.\\nEx. ExampleRole ðŸ˜ƒ\\nIf not, please reply with \"done\".\\nIf you would like to cancel the prompt, please respond with \"cancel\"\\n\\n${extra}`\n            message.edit(embedTemplate);\n            msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                    max: 1,\n                    time: 60000,\n                    errors: ['time'],\n                })\n                .then(async function(collected) {\n                    msg.author.lastMessage.delete();\n                    if (collected.first().content.toLowerCase() == \"done\") {\n                        if (reactionArray.length > 0) {\n                            done(message);\n                        } else {\n                            if (errorCatch > 0) {\n                                errorCatch -= 1;\n                                reAsk(message, `Please atleast attach 1 emoji to 1 role!\\nTries left - ${errorCatch}`)\n                            } else {\n                                message.delete();\n                                errorMessage(\"Prompt has been cancelled, you used the same emoji twice for differnt roles!\\nPlease re-execute the command to go through the prompt again!\");\n                            }\n                        }\n                    } else if (collected.first().content.toLowerCase() == \"cancel\") {\n                        message.delete();\n                        errorMessage(\"Prompt has been cancelled.\\nPlease re-execute the command to go through the prompt again!\");\n                    } else {\n                        var regString = collected.first().content;\n                        var execRegO = /[^\\x00-\\x7F]/g.exec(regString);\n                        var execRegT = /\\<:(.*?)\\>/g.exec(regString);\n                        var execRegTh = /\\<a:(.*?)\\>/g.exec(regString);\n                        var msgSplitArr = [[], [], []];\n\n                        if(execRegO != null){\n                            msgSplitArr[0] = [regString.substring(0, execRegO[\"index\"]),regString.substring(execRegO[\"index\"])];\n                        }\n                        if(execRegT != null){\n                            msgSplitArr[1] = [regString.substring(0, execRegT[\"index\"]),regString.substring(execRegT[\"index\"])];\n                        }\n                        if(execRegTh != null){\n                            msgSplitArr[2] = [regString.substring(0, execRegTh[\"index\"]),regString.substring(execRegTh[\"index\"])];\n                        }\n                        var filteredMsgSplit = await msgSplitArr.filter(item => item.length > 1);\n                        \n                        if (filteredMsgSplit.length > 0) {\n                            var msgSplit = filteredMsgSplit[0];\n                            const tstValidRole = await msg.guild.roles.find(role => role.name === msgSplit[0].replace(/\\s+$/, ''));\n\n                            if (collected.first().mentions.roles.first() || tstValidRole != null) {\n                                var unicodeStored = msgSplit[1];\n                                if (collected.first().mentions.roles.first() != null) {\n                                    roleMentioned = collected.first().mentions.roles.first();\n                                } else {\n                                    roleMentioned = tstValidRole;\n                                }\n                                if (unicodeStored != null) {\n                                    if (!roleArray.includes(roleMentioned.id) && !emojiArray.includes(unicodeStored)) {\n                                        if (unicodeStored.includes(\"<:\") || unicodeStored.includes(\"<a:\")) {\n                                            var emoji;\n\n                                            unicodeStored = unicodeStored.replace(/\\D/g, '');\n                                            emoji = localEmoji.filter(emojiT => emojiT.id == unicodeStored);\n                                            if (emoji.length > 0) {\n                                                unicodeStored = emoji[0];\n                                                delete unicodeStored['guild']\n                                                reactionArray.push([unicodeStored, roleMentioned.id, roleMentioned.name]);\n                                                emojiArray.push(unicodeStored);\n                                                roleArray.push(roleMentioned.id);\n                                                reAsk(message);\n                                            } else {\n                                                if (errorCatch > 0) {\n                                                    errorCatch -= 1;\n                                                    reAsk(message, `Please provide a valid custom emoji!\\n${localEmojiG}\\nTries left - ${errorCatch}`);\n                                                } else {\n                                                    message.delete();\n                                                    errorMessage(`Prompt has been cancelled, you provided an invalid custom emoji!\\n${localEmojiG}\\nPlease re-execute the command to go through the prompt again!`);\n                                                }\n                                            }\n                                        } else {\n                                            reactionArray.push([unicodeStored, roleMentioned.id, roleMentioned.name]);\n                                            emojiArray.push(unicodeStored);\n                                            roleArray.push(roleMentioned.id);\n                                            reAsk(message);\n                                        }\n                                    } else {\n                                        if (errorCatch > 0) {\n                                            errorCatch -= 1;\n                                            reAsk(message, `Please don't use the same emoji/role twice!\\nTries left - ${errorCatch}`)\n                                        } else {\n                                            message.delete();\n                                            errorMessage(\"Prompt has been cancelled, you used the same role twice in the prompt!\\nPlease re-execute the command to go through the prompt again!\");\n                                        }\n                                    }\n\n                                } else {\n                                    if (errorCatch > 0) {\n                                        errorCatch -= 1;\n                                        reAsk(message, `Please provide a valid emoji!\\nTries left - ${errorCatch}`)\n                                    } else {\n                                        message.delete();\n                                        errorMessage(\"Prompt has been cancelled, you didn't provide a valid emoji!\\nPlease re-execute the command to go through the prompt again!\");\n                                    }\n                                }\n                            } else {\n                                if (errorCatch > 0) {\n                                    errorCatch -= 1;\n                                    reAsk(message, `Please mention a valid role!\\nTries left - ${errorCatch}`)\n                                } else {\n                                    message.delete();\n                                    errorMessage(\"Prompt has been cancelled, you didn't mention a valid role!\\nPlease re-execute the command to go through the prompt again!\");\n                                }\n                            }\n                        } else {\n                            if (errorCatch > 0) {\n                                errorCatch -= 1;\n                                reAsk(message, `Please provide a valid emoji/role!\\nTries left - ${errorCatch}`)\n                            } else {\n                                message.delete();\n                                errorMessage(\"Prompt has been cancelled, you didn't provide a emoji/mentioned role!\\nPlease re-execute the command to go through the prompt again!\");\n                            }\n                        }\n                    }\n                }).catch((error) => {\n                    if (debug){\n                        console.log(error);\n                    }\n                    message.delete();\n                    errorMessage('Sorry, you didnt provide a valid response in time!\\nPlease re-execute the command to go through the prompt again!');\n                });\n        } else {\n            done(message);\n        }\n\n    }\n} else {\n    errorMessage(\"You do not have the `MANAGE ROLES` perimssion which is required to execute this command!\");\n}\n\n\n\nfunction done(message) {\n    var finalText = \"\";\n    reactionArray.forEach(subarray => {\n        finalText = finalText + `${subarray[0]} => ${subarray[2]}\\n`\n    })\n    embedTemplate[\"description\"] = `Final conformation menu\\n\\nBelow is the list of reactions to their roles\\n${finalText}\\n\\nIf this is correct, please respond with a mention to a text channel where the role menu will be sent.\\nIf this isn't correct, respond with \"cancel\" to cancel the prompt.`;\n    message.edit(embedTemplate);\n    msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n            max: 1,\n            time: 60000,\n            errors: ['time'],\n        })\n        .then((collected) => {\n            msg.author.lastMessage.delete();\n            if (collected.first().mentions.channels.first()) {\n                var menchannel = collected.first().mentions.channels.first()\n                message.delete();\n                menchannel.send({\n                        embed: {\n                            color: 0xffff00,\n                            title: embedSettings[0],\n                            description: `${embedSettings[1]}\\n\\n${finalText}`,\n                            timestamp: new Date()\n                        }\n                    })\n                    .then(embedmessage => {\n                        interval = setInterval(function() {\n                            emojiTimerInt(embedmessage, reactionArray);\n                        }, 500)\n                        rectarray[embedmessage.id] = reactionArray\n                        _this.storeValue(rectarray, 3, \"reactionRoleInf\", cache);\n                        fs.writeFile(\"./data/reactionRoleData.json\", JSON.stringify(rectarray), function(err) {\n                            if (err) {\n                                return console.log(err);\n                            }\n                        });\n                    })\n            } else if (collected.first().content == \"cancel\") {\n                message.delete();\n                errorMessage(\"Prompt has been cancelled.\\nPlease re-execute the command to go through the prompt again!\");\n            } else {\n                message.delete();\n                errorMessage(\"Prompt has been cancelled, you didn't provide a valid response!\\nPlease re-execute the command to go through the prompt again!\");\n            }\n        }).catch((error) => {\n            if (debug) {\n                console.log(error);\n            }\n            message.delete();\n            errorMessage('Sorry, you didnt provide a valid response in time!\\nPlease re-execute the command to go through the prompt again!')\n        });\n}\n\nfunction emojiTimerInt(message, subarray) {\n    message.react(subarray[emojiTimerRe][0])\n    emojiTimerRe += 1;\n\n    if (emojiTimerRe == subarray.length) {\n        clearInterval(interval);\n    }\n}\n\nfunction errorMessage(error) {\n    let errorTemplate = new Discord.RichEmbed({\n        color: 0xFF0000,\n        author: {\n            name: client.user.username,\n            icon_url: client.user.avatarURL\n        },\n        title: \"Role Reaction Prompt\",\n        description: error,\n        timestamp: new Date(),\n    })\n\n    msg.channel.send(errorTemplate);\n}",
      "storage": "0",
      "varName": "",
      "name": "Run Script"
    }
  ],
  "comType": "0"
}